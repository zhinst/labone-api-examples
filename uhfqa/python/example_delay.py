# Copyright 2018 Zurich Instruments AG

"""
Zurich Instruments LabOne Python API Example

Run a combined test of the monitor and result units.

The example applies a simple square wave to the instrument using the AWG. The
integration functions use the full length of the integrators, and each
integration function is basically just a constant value through the entire
integration window, with different values for the different channels. We
then sweep the starting point of the integration in relation to the pulse
generated by the AWG. Initially, the integrators will not see the pulse at
all, so the result will be zero. Then, as we gradually get more and more
overlap of the integration function and the pulse, we will see a ramp up
until a point in time where the integration window is completely within the
pulse. Then, for larger delays we have the reverse process.

Requirements:
    * LabOne Version >= 21.02
    * Instruments:
        1 x UHFQA Instrumemt.
    * Signal output 1 connected to signal input 1 with a BNC cable.
    * Signal output 2 connected to signal input 2 with a BNC cable.

Usage:
    example_delay.py [options] <device_id>
    example_delay.py -h | --help

Arguments:
    <device_id>  The ID of the device to run the example with. [device_type: UHFQA]

Options:
    -h --help                   Show this screen.
    --no-plot                   Hide plot of the recorded data.
    -l --monitor_length LENGTH  Number of monitor samples to obtain. [default: 4000]
    -a --num_averages VAL       Number of averages per measurement.  [default: 256]

Returns:
    data  Measurement result. (dict)

Raises:
    Exception     If the specified device does not match the requirements.
    RuntimeError  If the device is not "discoverable" from the API.

See the LabOne Programming Manual for further help:
https://docs.zhinst.com/labone_programming_manual/
"""

import sys
import time
import textwrap
import numpy as np
import zhinst.utils
import matplotlib.pyplot as plt
import common_uhfqa


def run_example(
    device_id: str,
    monitor_length: int = 4000,
    num_averages: int = 2 ** 8,
    plot: bool = True,
):
    """run the example."""

    apilevel_example = 6  # The API level supported by this example.
    # Call a zhinst utility function that returns:
    # - an API session `daq` in order to communicate with devices via the data server.
    # - the device ID string that specifies the device branch in the server's node hierarchy.
    # - the device's discovery properties.
    required_devtype = "UHFQA"
    required_options = None
    daq, device, _ = zhinst.utils.create_api_session(
        device_id,
        apilevel_example,
        required_devtype=required_devtype,
        required_options=required_options,
    )

    # Perform initialization for UHFQA examples
    common_uhfqa.initialize_device(daq, device)

    # Configure AWG
    awg_program = textwrap.dedent(
        """\
    const RATE = 0;
    const FS = 1.8e9*pow(2, -RATE);

    wave w = join(zeros(32), ones(64), -ones(64), zeros(32));

    var loop_cnt = getUserReg(0);
    var trig1;
    var trig0;
    if (getUserReg(1)) {
        trig1 = AWG_INTEGRATION_TRIGGER + AWG_INTEGRATION_ARM;
        trig0 = AWG_INTEGRATION_ARM;
    } else {
        trig1 = AWG_MONITOR_TRIGGER;
        trig0 = 0;
    }

    repeat(loop_cnt) {
        playWave(w, -w, RATE);
        wait(25);
        setTrigger(trig1);
        setTrigger(trig0);
        waitWave();
        wait(1000);
    }
    """
    )

    # Create an instance of the AWG module
    awgModule = daq.awgModule()
    awgModule.set("device", device)
    awgModule.set("index", 0)
    awgModule.execute()

    # Transfer the AWG sequence program. Compilation starts automatically.
    awgModule.set("compiler/sourcestring", awg_program)
    while awgModule.getInt("compiler/status") == -1:
        time.sleep(0.1)

    # Ensure that compilation was successful
    assert awgModule.getInt("compiler/status") != 1

    # Channels to test
    channels = [0, 1, 2, 3, 4, 5, 6, 7]

    # Configuration of weighted integration
    integration_length = 4
    for i in range(4):
        weights = np.zeros(integration_length)
        weights[i] = 1
        daq.setVector(f"/{device:s}/qas/0/integration/weights/{i}/real", weights)
        daq.setVector(
            f"/{device:s}/qas/0/integration/weights/{i}/imag",
            np.zeros(integration_length),
        )
        daq.setVector(
            f"/{device:s}/qas/0/integration/weights/{i + 4}/real",
            np.zeros(integration_length),
        )
        daq.setVector(f"/{device:s}/qas/0/integration/weights/{i + 4}/imag", weights)

    daq.setInt(f"/{device:s}/qas/0/integration/length", integration_length)
    daq.setInt(f"/{device:s}/qas/0/integration/mode", 0)
    daq.setInt(f"/{device:s}/qas/0/delay", 0)

    # Apply a rotation on half the channels to get the imaginary part instead
    for i in range(4):
        daq.setComplex(f"/{device:s}/qas/0/rotations/{i:d}", 1)
        daq.setComplex(f"/{device:s}/qas/0/rotations/{i + 4:d}", -1j)

    #
    # First, perform a measurement with the monitor unit.
    #

    # Setup monitor
    daq.setInt(f"/{device:s}/qas/0/monitor/averages", num_averages)
    daq.setInt(f"/{device:s}/qas/0/monitor/length", monitor_length)

    # Now we're ready for readout. Enable monitor and start acquisition.
    daq.setInt(f"/{device:s}/qas/0/monitor/reset", 1)
    daq.setInt(f"/{device:s}/qas/0/monitor/enable", 1)
    daq.sync()

    # Set number of signal repetitions in AWG program
    daq.setDouble(f"/{device:s}/awgs/0/userregs/0", num_averages)

    # Trigger monitor from within the AWG program
    daq.setDouble(f"/{device:s}/awgs/0/userregs/1", 0)

    # Subscribe to monitor waves
    monitor_paths = []
    for channel in range(2):
        path = f"/{device:s}/qas/0/monitor/inputs/{channel:d}/wave"
        monitor_paths.append(path)
    daq.subscribe(monitor_paths)

    # Arm the device
    daq.asyncSetInt(f"/{device:s}/awgs/0/single", 1)
    daq.syncSetInt(f"/{device:s}/awgs/0/enable", 1)

    # Perform acquisition
    print("Acquiring monitor data...")
    monitor_data = common_uhfqa.acquisition_poll(daq, monitor_paths, monitor_length)
    print("Done.")

    # Stop monitor
    daq.unsubscribe(monitor_paths)
    daq.setInt(f"/{device:s}/qas/0/monitor/enable", 0)

    #
    # Next, perform the same measurement with the result unit.
    #

    # Trigger result unit from within the AWG program
    daq.setDouble(f"/{device:s}/awgs/0/userregs/1", 1)

    # Configure the result unit
    result_length = 1
    daq.setInt(f"/{device:s}/qas/0/result/length", result_length)
    daq.setInt(f"/{device:s}/qas/0/result/averages", num_averages)
    daq.setInt(
        f"/{device:s}/qas/0/result/source", common_uhfqa.ResultLoggingSource.TRANS
    )

    # Now we're ready for readout. Enable result unit and start acquisition.
    daq.setInt(f"/{device:s}/qas/0/result/reset", 1)
    daq.setInt(f"/{device:s}/qas/0/result/enable", 1)
    daq.sync()

    # Subscribe to result waves
    result_paths = []
    for channel in channels:
        path = f"/{device:s}/qas/0/result/data/{channel:d}/wave"
        result_paths.append(path)
    daq.subscribe(result_paths)

    print("Acquiring result data...")
    result_data = {k: [] for k in result_paths}
    for delay in range(50):
        print(".", end="")
        sys.stdout.flush()
        daq.setInt(f"/{device:s}/qas/0/delay", 4 * delay)

        # Arm the device
        daq.asyncSetInt(f"/{device:s}/awgs/0/single", 1)
        daq.syncSetInt(f"/{device:s}/awgs/0/enable", 1)

        data = common_uhfqa.acquisition_poll(daq, result_paths, result_length)
        for path in result_paths:
            result_data[path] = np.r_[result_data[path], data[path]]

    print("\nDone.")

    daq.unsubscribe(result_paths)
    daq.setInt(f"/{device:s}/qas/0/result/enable", 0)

    def combine_results(channels):
        """Combine result waveforms into I and Q result"""
        waves = [
            result_data[f"/{device:s}/qas/0/result/data/{ch:d}/wave"] for ch in channels
        ]
        return np.ravel(waves, order="F")

    result_i = combine_results([0, 1, 2, 3])
    result_q = combine_results([4, 5, 6, 7])
    residual_i = monitor_data[monitor_paths[0]][:200] - result_i
    residual_q = monitor_data[monitor_paths[1]][:200] - result_q

    if plot:
        fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 6), sharex=True)
        axes[0, 0].set_title("Monitor and Result")
        axes[0, 0].set_ylabel("Amplitude (a.u.)")
        axes[0, 0].set_xlim(0, 200)
        axes[0, 0].plot(monitor_data[monitor_paths[0]], label="Monitor 0")
        axes[0, 0].plot(result_i, "--", label="Result")
        axes[0, 0].legend(loc="upper right")
        axes[1, 0].set_ylabel("Amplitude (a.u.)")
        axes[1, 0].set_xlabel("Sample (#)")
        axes[1, 0].plot(monitor_data[monitor_paths[1]], label="Monitor 1")
        axes[1, 0].plot(result_q, "--", label="Result")
        axes[1, 0].legend(loc="lower right")
        axes[0, 1].set_title("Residual Error")
        axes[0, 1].set_ylabel("Amplitude (a.u.)")
        axes[0, 1].plot(residual_i)
        axes[1, 1].set_ylabel("Amplitude (a.u.)")
        axes[1, 1].set_xlabel("Sample (#)")
        axes[1, 1].plot(residual_q)
        fig.set_tight_layout(True)
        plt.show()

    # Check residuals
    assert np.all(residual_i < 0.05)
    assert np.all(residual_q < 0.05)

    return monitor_data, (result_i, result_q)


if __name__ == "__main__":
    from pathlib import Path

    cli_util_path = Path(__file__).resolve().parent / "../../utils/python"
    sys.path.insert(0, str(cli_util_path))
    cli_utils = __import__("cli_utils")
    cli_utils.run_commandline(run_example, __doc__)
    sys.path.remove(str(cli_util_path))
